{"meta":{"title":"没有比人更高的山，没有比脚更远的路","subtitle":"Good good study day day up","description":"专注于技术分享","author":"diyxiaoshitou","url":"http://diyxiaoshitou.github.io"},"pages":[{"title":"","date":"2016-07-28T05:16:21.000Z","updated":"2016-07-28T05:16:21.000Z","comments":true,"path":"404.html","permalink":"http://diyxiaoshitou.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2016-11-08T18:55:38.000Z","updated":"2016-11-08T18:55:38.000Z","comments":false,"path":"categories/index.html","permalink":"http://diyxiaoshitou.github.io/categories/index.html","excerpt":"","text":"看 ``"},{"title":"happy","date":"2016-06-14T11:52:42.000Z","updated":"2016-06-14T11:52:42.000Z","comments":true,"path":"happy/index.html","permalink":"http://diyxiaoshitou.github.io/happy/index.html","excerpt":"","text":"看 ``"},{"title":"","date":"2016-11-08T17:59:11.000Z","updated":"2016-11-08T17:59:11.000Z","comments":false,"path":"tags/index.html","permalink":"http://diyxiaoshitou.github.io/tags/index.html","excerpt":"","text":"看 ``"}],"posts":[{"title":"用js触发CSS3-transition过渡动画","slug":"用js触发CSS3-transition过渡动画","date":"2017-02-09T01:35:36.000Z","updated":"2017-02-09T02:04:43.000Z","comments":true,"path":"2017/02/09/用js触发CSS3-transition过渡动画/","link":"","permalink":"http://diyxiaoshitou.github.io/2017/02/09/用js触发CSS3-transition过渡动画/","excerpt":"","text":"一、通过事件（划过，点击）等来触发动画经过这几天的工作，让我进一步的了解到CSS3的强大，原本许多需要js才能实现的动画效果，现在通过CSS3就能轻易实现了，但是CSS3也有自身的不足，例如说在动画出发触发上就没有js灵活，因此我就开始考虑将CSS3与Js结合使用。不过要注意CSS3属性兼容性问题 平时我们直接使用transition动画一般是这样的鼠标放置在div方块上触发动画效果（鼠标悬浮div上即可触发） 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style type=\"text/css\"&gt; .test&#123; background: red; width: 100px; height: 100px; transition: all 1s; -moz-transition: all 1s; -webkit-transition: all 1s; -o-transition:all 1s; &#125; .test:hover&#123; background: red; width: 200px; height: 200px; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=\"div\" class=\"test\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 现在如果想用js控制transition过渡动画怎么办呢？最开始我是想和CSS控制动画一样，直接改变其className，但是发现没有动画效果。后来经过了一番探索发现，通过dom操作其css属性就行了。js操作动画设置如下 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style type=\"text/css\"&gt; .test&#123; background: red; width: 100px; height: 100px; transition: all 1s; -moz-transition: all 1s; -webkit-transition: all 1s; -o-transition:all 1s; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=\"div\" class=\"test\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; document.getElementById(\"div\").onclick=function()&#123; document.getElementById(\"div\").style.width=\"200px\" document.getElementById(\"div\").style.height=\"200px\" &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 二、页面加载时自动加载动画这么样实现页面加载时自动加载动画呢，js直接改变其className能实现触发动画效果,方法是js操作是需要用到 setTimeout 函数，当页面已加载时就会实现动画效果12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;style type=\"text/css\"&gt;.test &#123; background: red; width: 100px; height: 100px; transition: all 1s; -moz-transition: all 1s; -webkit-transition: all 1s; -o-transition: all 1s;&#125;.fade &#123; width: 200px; height: 200px;&#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"div\" class=\"test\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; setTimeout(function() &#123;document.getElementById(\"div\").className = \"test fade\"&#125;,0) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"css3","slug":"css3","permalink":"http://diyxiaoshitou.github.io/tags/css3/"}],"keywords":[]},{"title":"node+express+mongodb登录实例","slug":"node-express-mongodb登录实例","date":"2016-12-07T08:16:20.000Z","updated":"2016-12-07T08:56:58.000Z","comments":true,"path":"2016/12/07/node-express-mongodb登录实例/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/12/07/node-express-mongodb登录实例/","excerpt":"","text":"刚了解nodejs,发现nodejs配置起来不复杂,但也有很多需要注意的地方,今天就记录一下,以后也可拿出来看看.要完成这个简单的示例,从零开始,走三步就行了. 一.搭建开发环境1. nodejs到官方网站下载最新版本 http://www.nodejs.org/, 下载之后,安装,一路 next2 配置 path 把上面安装的目录配置到环境变量中,方便以后用命令行的方式使用node.exe.比如我的 node.exe 在 “H:\\Program Files\\nodejs\\node.exe”, 在环境变量最开始加上 “H:\\Program Files\\nodejs\\;” 2. mongodb1 安装 http://www.mongodb.org/downloads 下载, 建议下载 zip 版,开发的时候,不需要安装,直接解压就可以用了. 使用命令行方式启动 mongodb1\\&gt;mongod 127.0.0.1:27017 --dbpath D:\\mongodb\\dbone //D:\\mongodb\\dbone mongodb和dbone文件夹要自己先建立好, 另外, --dbpath 参数值中间不能有空格 二.创建项目(express) 1 .安装全局插件 >nmp install -g express //自动下载 express 插件 >nmp install -g express-generator //express 在命令行中的工具 2. 添加项目 >express -e webapp >cd webapp >npm install //让npm根据 package.json 自动下载依赖包 >npm install mongo &amp;&amp; npm install express-mongo //下载 mongodb 支持包 上面我们已经生成好了app原型，接着我们设计数据库cmd命令行里：mongo //进入数据库use hello-world //创建项目数据库db.addUser(“shuaige”, “123456”) //给这个数据库创建了一个叫帅哥的账号，密码123456 （但是我觉得可能我理解的不到位，你也可以不做这个操作）然后，我们就为这个hello-world数据库创建collection（collection就相当于oracle和mysql里的table）db.createCollection(“users”) //创建一个集合，也就是表db.users.insert({userid: “admin”, password: “123456”}) //给users里添加一个文档，也就是一条记录账号admin，密码123456ok，现在检查一下：db.users.find() //如果看到你刚刚添加的文档记录，就ok咯 三.编码1.修改模版规则 app.js 中1app.set(&apos;view engine&apos;, &apos;ejs&apos;); 修改成:12app.engine(&apos;html&apos;, require(&apos;ejs&apos;).__express);app.set(&apos;view engine&apos;, &apos;html&apos;); 把 /views/ 中的文件后缀改成 *.html 2.添加页面(又称视图) index.html 点击”登录” 跳转到 login.html, 登录功之后,跳转到 home.html, 在 home.html 点击注销之后跳转到 login.html /views/login.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;form method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"userid\" id=\"userid\"/&gt;&lt;br/&gt; 密 码:&lt;input type=\"password\" name=\"password\" id=\"password\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; /views/home.html123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;欢迎光临: &lt;%= userid %&gt;&lt;/p&gt; &lt;h1&gt;&lt;a href=\"/logout\"&gt;注销&lt;/a&gt;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 修改 /views/index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &lt;h1&gt;&lt;a href=\"/login\"&gt;登录&lt;/a&gt;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 3.添加 model添加 /routes/models.js12345678var mongo = require('mongoose');var Schema = mongo.Schema;var UserSchema = new Schema(&#123; userid: String, name: String, password: String&#125;);exports.User = mongo.model('User', UserSchema); 4.修改路由修改 /routes/index.js1234567891011121314151617181920212223242526272829303132333435363738394041var express = require('express');var router = express.Router();var mongo = require('mongoose'); //var models = require('./models'); //引入 modelvar User = models.User;mongo.connect('mongodb://192.168.199.9:8888/logindb'); //连接数据库/* GET home page. */router.get('/', function(req, res) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);router.get('/login', function(req, res) &#123; //转到登录页面 res.render('login', &#123; title: '登录' &#125;);&#125;);router.post('/login', function(req, res) &#123; //处理登录请求 var query_doc = &#123; userid: req.body.userid, password: req.body.password &#125;; User.count(query_doc, function(err, doc)&#123; if(doc == 1)&#123;//验证成功,转到 欢迎页面 res.redirect('/home?userid=' + query_doc.userid); &#125;else&#123; res.redirect('/login'); &#125; &#125;);&#125;);router.get('/logout', function(req, res) &#123;//注销,转到登录页面 res.redirect('/login');&#125;);router.get('/home', function(req, res) &#123;//欢迎页面 var userid = req.query.userid; res.render('welcome', &#123; title: '', userid: userid&#125;);&#125;);module.exports = router; 5.运行 5.1.启动 app.js1 &gt;node ./bin/www 5.2 用浏览器访问 http://localhost:3000/git项目地址：https://github.com/diyxiaoshitou/node_mongodb_express","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://diyxiaoshitou.github.io/tags/node/"}],"keywords":[]},{"title":"jQuery对象和DOM对象之间的转换实现","slug":"jQuery对象和DOM对象之间的转换实现","date":"2016-11-23T07:29:42.000Z","updated":"2016-11-23T07:32:07.000Z","comments":true,"path":"2016/11/23/jQuery对象和DOM对象之间的转换实现/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/11/23/jQuery对象和DOM对象之间的转换实现/","excerpt":"","text":"本文主要向大家介绍了jQuery对象和DOM对象之间互相转换的方法，其实转换过程十分简单，一起来看看吧。在讨论jQuery对象和DOM对象的相互交换之前，先约定好定义变量的风格。如果获取的对象是jQuery对象，那么在变量前加上$，例如：var $variable = jQuery对象;如果获取的是DOM对象，则定义如下：var variable = DOM对象； 1.jQuery对象转成DOM对象jQuery对象不能使用DOM中的方法，但是如果对jQuery对象所提供的方法不熟悉，或者jQuery没有封装想要的方法，不得不实用DOM对象的时候，有以下两种处理方法。jQuery提供了两种方法将一个jQuery对象转换成DOM对象，即[index]和get(index). (1)jQuery对象是一个数组对象，可以通过[index]的方法得到相应的DOM对象。jQuery代码如下：12var $cr = $(\"#cr\"); //jQuery对象var cr = $cr[0] //DOM对象alert(cr.checked) //检测这个checkbox是否选中了 (2)另一种方法是jQuery本身提供的，通过get(index)方法得到相应的DOM对象。jQuery代码如下：1var $cr = $(\"#cr\");var cr = $cr.get(0);alert(cr.checked) 2.DOM对象转换成jQuery对象对于一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个jQuery对象了，方式为$(DOM对象)。jQuery代码如下：1var cr = document.getElementByID(\"cr\"); //DOM对象var $cr = $(cr); 转换后，可以任意使用jQuery中的方法。通过以上方法，可以任意地相互转换jQuery对象和DOM对象。最后强调，DOM对象才能使用DOM中的方法，jQuery对象不可以使用DOM中的方法，但jQuery对象提供了一套更加完善的工具用于操作DOM。","categories":[],"tags":[],"keywords":[]},{"title":"跨域","slug":"跨域","date":"2016-11-23T02:12:44.000Z","updated":"2016-11-23T02:28:25.000Z","comments":true,"path":"2016/11/23/跨域/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/11/23/跨域/","excerpt":"","text":"什么是跨域JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下： 首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表： URL 说明 是否允许通信http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许http://www.a.com/lab/a.jshttp://www.a.com/script/b.js 同一域名下不同文件夹 允许http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名，不同端口 不允许http://www.a.com/a.jshttps://www.a.com/b.js 同一域名，不同协议 不允许http://www.a.com/a.jshttp://70.32.92.74/b.js 域名和域名对应ip 不允许http://www.a.com/a.jshttp://script.a.com/b.js 主域相同，子域不同 不允许http://www.a.com/a.jshttp://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）http://www.cnblogs.com/a.jshttp://www.a.com/b.js 不同域名 不允许特别注意两点：第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。接下来简单地总结一下在“前台”一般处理跨域的办法，后台proxy这种方案牵涉到后台配置，这里就不阐述了，有兴趣的可以看看yahoo的这篇文章：《JavaScript: Use a Web Proxy for Cross-Domain XMLHttpRequest Calls》 1.document.domain+iframe的设置对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com那显然是会报错地！代码如下： www.a.com上的a.html12345678910document.domain = 'a.com';var ifr = document.createElement('iframe');ifr.src = 'http://script.a.com/b.html';ifr.style.display = 'none';document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(\"h1\")[0].childNodes[0].nodeValue);&#125;; script.a.com上的b.html1document.domain = 'a.com'; 这种方式适用于{www.kuqin.com, kuqin.com, script.kuqin.com, css.kuqin.com}中的任何页面相互通信。 备注：某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如a.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名。 domain只能设置为主域名，不可以在b.a.com中将domain设置为c.a.com。 问题：1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。 2、动态创建script虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。具体的做法可以参考YUI的Get Utility 这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。123456js.onload = js.onreadystatechange = function() &#123; if (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete') &#123; // callback在此处执行 js.onload = js.onreadystatechange = null; &#125;&#125;; 3、利用iframe和location.hash这个办法比较绕，但是可以解决完全跨域情况下的脚步置换问题。原理是利用location.hash来进行传值。在url： http://a.com#helloword 中的 ‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。代码如下： 先是a.com下的文件cs1.html文件：12345678910111213141516function startRequest()&#123; var ifr = document.createElement('iframe'); ifr.style.display = 'none'; ifr.src = 'http://www.cnblogs.com/lab/cscript/cs2.html#paramdo'; document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : ''; if (console.log) &#123; console.log('Now the data is '+data); &#125; &#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000); cnblogs.com域名下的cs2.html:12345678910111213141516171819202122//模拟一个简单的参数处理操作switch(location.hash)&#123; case '#paramdo': callBack(); break; case '#paramset': //do something…… break;&#125;function callBack()&#123; try &#123; parent.location.hash = 'somedata'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， // 所以要利用一个中间的cnblogs域下的代理iframe var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = 'http://a.com/test/cscript/cs3.html#somedata'; // 注意该文件在\"a.com\"域下 document.body.appendChild(ifrproxy); &#125;&#125; a.com下的域名cs3.html12//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等…… 4、window.name实现的跨域数据传输文章较长列在此处不便于阅读，详细请看 window.name实现的跨域数据传输。 5、使用HTML5 postMessageHTML5中最酷的新功能之一就是 跨文档消息传输Cross Document Messaging。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。 otherWindow.postMessage(message, targetOrigin); otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message: 所要发送的数据，string类型。targetOrigin: 用于限制otherWindow，’* ‘表示不作限制 a.com/index.html中的代码： 123456789&lt;iframe id=\"ifr\" src=\"b.com/index.html\"&gt;&lt;/iframe&gt;&lt;script type=\"text/javascript\"&gt;window.onload = function() &#123; var ifr = document.getElementById('ifr'); var targetOrigin = 'http://b.com'; // 若写成'http://b.com/c/proxy.html'效果一样 // 若写成'http://c.com'就不会执行postMessage了 ifr.contentWindow.postMessage('I was there!', targetOrigin);&#125;;&lt;/script&gt; b.com/index.html中的代码：12345678910&lt;script type=\"text/javascript\"&gt; window.addEventListener('message', function(event)&#123; // 通过origin属性判断消息来源地址 if (event.origin == 'http://a.com') &#123; alert(event.data); // 弹出\"I was there!\" alert(event.source); // 对a.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 &#125; &#125;, false);&lt;/script&gt; 参考文章：《精通HTML5编程》第五章——跨文档消息机制、https://developer.mozilla.org/en/dom/window.postmessage 6、利用flash这是从YUI3的IO组件中看到的办法，具体可见http://developer.yahoo.com/yui/3/io/。可以看在Adobe Developer Connection看到更多的跨域代理文件规范：ross-Domain Policy File Specifications、HTTP Headers Blacklist。","categories":[],"tags":[],"keywords":[]},{"title":"小球运动","slug":"小球运动","date":"2016-11-14T16:15:53.000Z","updated":"2016-11-14T17:17:38.000Z","comments":true,"path":"2016/11/15/小球运动/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/11/15/小球运动/","excerpt":"","text":"用原生的方法实现小球的运动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style type=\"text/css\"&gt; .ball &#123; width: 40px; height: 40px; border-radius: 20px; &#125; .ball1 &#123; background: red; &#125; .ball2 &#123; background: yellow; &#125; .ball3 &#123; background: green; &#125; &lt;/style&gt; &lt;div class=\"ball ball1\" style=\"margin-left:0;\"&gt;&lt;/div&gt; &lt;div class=\"ball ball2\" style=\"margin-left:0;\"&gt;&lt;/div&gt; &lt;div class=\"ball ball3\" style=\"margin-left:0;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var ball1 = document.querySelector(\".ball1\") var ball2 = document.querySelector(\".ball2\") var ball3 = document.querySelector(\".ball3\") function animate(ball, distance, cb) &#123; setTimeout(function() &#123; var marginLeft = parseInt(ball.style.marginLeft, 10) if (marginLeft === distance) &#123; cb &amp;&amp; cb() &#125; else &#123; if (marginLeft &lt; distance) &#123; marginLeft++; &#125; else &#123; marginLeft--; &#125; console.log('1'); ball.style.marginLeft = marginLeft +'px'; animate(ball, distance, cb) &#125; &#125;, 13) &#125; animate(ball1, 100, function() &#123; animate(ball2, 200, function() &#123; animate(ball3, 300, function() &#123; animate(ball3, 150, function() &#123; animate(ball2, 150, function() &#123; animate(ball1, 150, function() &#123; &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过promise改进后的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"node_modules/bluebird/js/browser/bluebird.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;style type=\"text/css\"&gt; .ball &#123; width: 40px; height: 40px; border-radius: 20px; &#125; .ball1 &#123; background: red; &#125; .ball2 &#123; background: yellow; &#125; .ball3 &#123; background: green; &#125; &lt;/style&gt; &lt;div class=\"ball ball1\" style=\"margin-left:0;\"&gt;&lt;/div&gt; &lt;div class=\"ball ball2\" style=\"margin-left:0;\"&gt;&lt;/div&gt; &lt;div class=\"ball ball3\" style=\"margin-left:0;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var ball1 = document.querySelector(\".ball1\") var ball2 = document.querySelector(\".ball2\") var ball3 = document.querySelector(\".ball3\") var Promise = window.Promise; function promiseAnimate(ball, distance) &#123; return new Promise(function(resolve, reject) &#123; function _animate() &#123; setTimeout(function() &#123; var marginLeft = parseInt(ball.style.marginLeft, 10) if (marginLeft === distance) &#123; resolve() &#125; else &#123; if (marginLeft &lt; distance) &#123; marginLeft++; &#125; else &#123; marginLeft--; &#125; console.log('1'); ball.style.marginLeft = marginLeft + 'px'; _animate() &#125; &#125;, 13) &#125; _animate(); &#125;) &#125; promiseAnimate(ball1,100) .then(function() &#123; return promiseAnimate(ball2,200) &#125;) .then(function() &#123; return promiseAnimate(ball3,300) &#125;) .then(function() &#123; return promiseAnimate(ball3,150) &#125;) .then(function() &#123; return promiseAnimate(ball2,150) &#125;) .then(function() &#123; return promiseAnimate(ball1,150) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"jascript","slug":"jascript","permalink":"http://diyxiaoshitou.github.io/tags/jascript/"}],"keywords":[]},{"title":"我们需要什么的前端环境","slug":"我们需要什么的前端环境","date":"2016-11-11T16:21:08.000Z","updated":"2016-11-12T04:10:08.000Z","comments":true,"path":"2016/11/12/我们需要什么的前端环境/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/11/12/我们需要什么的前端环境/","excerpt":"","text":"1.代码编辑工具sublime, IntelliJ IDEA 2.断点调试工具chrome断电调试工具插件 Batarang 3.版本管理工具git 4.代码合并和混淆工具gulp, grunt 5.依赖管理工具bower 的优势：1.自动安装依赖的组件 2.组件间的依赖检测 3.版本兼容性自动检测 6.单元测试工具 (karma ,jasmine)轻量级Server:http-server 可以模拟测试数据单元测试神器karma单元测试 jasmine 7.集成测试工具 （模拟键盘和鼠标操作）专门为angular定制的测试工具 Protractor","categories":[],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://diyxiaoshitou.github.io/tags/Angular/"}],"keywords":[]},{"title":"从一行代码里面学点JavaScript","slug":"从一行代码里面学点JavaScript","date":"2016-11-02T09:40:03.000Z","updated":"2016-11-08T19:03:21.000Z","comments":true,"path":"2016/11/02/从一行代码里面学点JavaScript/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/11/02/从一行代码里面学点JavaScript/","excerpt":"","text":"现如今，JavaScript无处不在，因此关于JavaScript的新知识也是层出不穷。JavaScript的特点在于，要学习它的语法入门简简单，但是要精通使用它的方式却是一件不容易的事。 来看看下面的这段代码，它来自于谷歌“名猿”Addy Osmani在几天前贴出的一段代码，它的作用是用来调试你的CSS层。全部代码只有三行，但是你绝对可以把它放在一行里面完成： 12[].forEach.call($$(\"*\"),function(a)&#123; a.style.outline=\"1px solid #\"+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;) 现在，在你的Chrome浏览器的控制台中输入这段代码，你会发现不同HTML层都被使用不同的颜色添加了一个高亮的边框。是不是非常酷？但是，简单来说，这段代码只是首先获取了所有的页面元素，然后使用一个不同的颜色为它们添加了一个1ps的边框。想法很简单，但是真要实现起来却不是那么容易的一件事。在下面的内容中，我们将一起一步一步学习如何理解上面的这段代码。 选择页面中所有的元素我们需要做的第一件事情是获取页面中所有的元素，在上面的代码中，Addy使用了一个Chrome浏览器中特有的函数$$。你可以在你的Chrome浏览器控制台中输入$$(‘a’)，然后你就能得到一个当前页面中所有锚元素的列表。 $$函数是许多现代浏览器命令行API中的一个部分，它等价于document.querySelectorAll,你可以将一个CSS选择器作为这个函数的参数，然后你就能够获得当前页面中所有匹配这个CSS选择器的元素列表。如果你在浏览器控制台以外的地方，你可以使用document.querySelectorAll(‘‘)来代替$$(‘‘)。更多关于$$函数的详细内容可以查看Chrome开发者工具的文档。 当然，除了使用$$函数之外，我们还有一种更简单的方法，document.all，虽然这并不是一种很规范的使用方法，但是它几乎在每一个浏览器中都能运行成功。 迭代所有的元素经过第一步，我们已经获得了页面内所有的元素，现在我们想做的事情是遍历每一个元素，然后为它们添加一个彩色边边框。但是上面的代码究竟是怎么一回事呢？1[].forEach.call( $$('*'), function( element ) &#123; /* 在这里修改颜色 */ &#125;); 首先，我们通过选择器获得的列表是一个NodeLists对象，它和JavaScript中的数组有点像，你可以使用方括号来获取其中的节点，你也可以检查它其中包含多少个元素，但是它并没有实现数组包含的所有方法，因此我们并不能使用$$(‘*’).forEach()来进行迭代。在JavaScript中，有好几个类似于数组但是并不是数组的对象，除了前面的NodeLists，还有函数的参数集合arguments，在这里我们可以使用call或apply函数将函数的方法运用到这些对象上。例如下面的例子：123function say(name) &#123; console.log( this + ' ' + name );&#125;say.call( 'hola', 'Mike' ); // 打印 'hola Mike'// 你也可以将这种方法有用在arguments对象上 function example( arg1, arg2, arg3 ) &#123; return Array.prototype.slice.call(arguments, 1); // Returns [arg2, arg3] &#125; 在Addy的代码中，使用了[].forEach.call而不是Array.prototype.forEach.call，二者等价，但是前者可以节省几个字节。 为元素添加颜色为了让元素都有一个漂亮的边框，我们在上面的代码中使用了CSS属性outline。outline属性位于CSS盒模型之外，因此它并不影响元素的属性或者元素在布局中的位置，这对于我们来说非常有用。这个属性和修改border属性非常类似，因此下面的代码应该不会很难理解：1a.style.outline=\"1px solid #\" + color 真正有趣的地方在于定义颜色部分：1~~(Math.random()*(1&lt;&lt;24))).toString(16) 天呐，上面的代码是什么意思？在JavaScript中，比特操作符并不是经常被使用，因此这里可能会让很多程序员感到很疑惑。 我们想达到的目的是活的一个十六进制格式的颜色例如白色对应的是FFFFFF，蓝色对应的是0000FF，或者随便一个颜色37f9ac。虽然我们人类喜欢十进制，但是我们的代码常常会需要十六进制的东西。 我们首先要学会如何使用toString函数将一个十进制的数组转换为一个十六进制整数。这个函数可以接受一个参数，如果参数缺省，默认为十进制，但是你完全可以使用别的数组：1(30).toString(); // \"30\"(30).toString(10); // \"30\"(30).toString(16); // \"1e\" 十六进制(30).toString(2); // \"11110\" 二进制(30).toString(36); // \"u\" 36是允许的最大参数值 除此之外，你可以使用parseInt函数将十六进制数字转换为十进制。1parseInt(\"30\"); // \"30\"parseInt(\"30\", 10); // \"30\"parseInt(\"1e\", 16); // \"30\"parseInt(\"11110\", 2); // \"30\"parseInt(\"u\", 36); // \"30\" 因此，我们现在只需要一个位于0和ffffff之间的十六进制数，由于:1parseInt(\"ffffff\", 16) == 16777215 而这里的16777215实际上是2^24-1。 如果你对二进制数学熟悉的话，你可能会知道1&lt;&lt;24 == 16777216。 再进一步，你每在1后面添加一个0，你就相当于多做了一次2的乘方：11 // 1 == 2^0100 // 4 == 2^210000 // 16 == 2^41000000000000000000000000 // 16777216 == 2^24 因此，在这里我们可以知道Math.random()*(1&lt;&lt;24)表示一个位于0和16777216之间的数。 但是这里并没有结束，因为Math.random返回的是一个浮点数，但是我们只想要整数部分。我们的代码中使用波浪号操作符来完成这件事。波浪操作符在JavaScript中被用来对一个变量进行取反。 但是我们在这里并不关心取反，我们指向获取整数部分。因此我们还可以知道两次取反可以去掉一个浮点数的小数部分，因此~~的作用相当于parseInt：1var a = 12.34, // ~~a = 12 b = -1231.8754, // ~~b = -1231 c = 3213.000001 // ~~c = 3213;~~a == parseInt(a, 10); // true~~b == parseInt(b, 10); // true~~c == parseInt(c, 10); // true 当然，我们还有一种更加简洁的方法，使用OR操作符：1~~a == 0|a == parseInt(a, 10)~~b == 0|b == parseInt(b, 10)~~c == 0|c == parseInt(c, 10) 最终，我们获得了一个位于0和16777216之间的随机整数，也就是我们想要的随机颜色。此时我们只需要使用toString(16)将它转化为十六进制数即可。 总结 现在，你已经完全理解了前面的这一行代码中的各个部分。作为一个程序员，我们应该在完成工作之后多问自己几遍为什么，还有没有更好更简洁的方法。当然，最应该做的事情当然是多阅读程序代码，也许你就能从某一行代码中学到很多新东西。","categories":[{"name":"学习","slug":"学习","permalink":"http://diyxiaoshitou.github.io/categories/学习/"}],"tags":[{"name":"js","slug":"js","permalink":"http://diyxiaoshitou.github.io/tags/js/"},{"name":"试题","slug":"试题","permalink":"http://diyxiaoshitou.github.io/tags/试题/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://diyxiaoshitou.github.io/categories/学习/"}]},{"title":"试题","slug":"试题","date":"2016-11-02T06:50:37.000Z","updated":"2016-11-18T03:12:37.000Z","comments":true,"path":"2016/11/02/试题/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/11/02/试题/","excerpt":"","text":"1.写一个通用的事件侦听器函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// &lt;!-- 通用的侦听函数 --&gt; markyun = &#123;&#125; markyun.Event = &#123; readyEvent: function(fn) &#123; if (fn == null) &#123; fn = document; &#125; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn() &#125; &#125; &#125;, addEvent: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element['on' + type] = handler; &#125; &#125;, // 移除事件 removeEvent: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.datachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 阻止事件（主要是时间冒泡，因为ie不支持事件捕获） stopPropagation: function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件默认行为 preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, // 获取对象的引用，渠道时间的所有信息，确保随时使用event; getEvent: function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.anguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125; &#125; 2.Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？123456789hasOwnPropertyjavaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。使用方法：object.hasOwnProperty(proName)其中参数object是必选项。一个对象的实例。proName是必选项。一个属性名称的字符串值。如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。 3.统计一个字符串出现最多的字母123456789101112131415161718var strs = \"adadfdfseffserfefsefseeffffftsdg\"; //命名一个变量放置给出的字符串 var kk = getMaxStrLength(strs); console.log(kk); function getMaxStrLength(str) &#123; var maxLength = 0; var result = ''; while (str !== '') &#123; var oldStr = str; var firstStr = str.substring(0, 1); str = str.replace(new RegExp(firstStr, 'g'), ''); if (oldStr.length - str.length &gt; maxLength) &#123; maxLength = oldStr.length - str.length; result = firstStr + \"=\" + maxLength; &#125; &#125; return result; &#125; 4.随机生成指定长度的字符串1234567891011function randomString(n)&#123; var str = 'abcdefghijklmnopqrstuvwxyz9876543210'; var tmp = '', i = 0, l = str.length; for (var i = 0; i&lt;n; i++) &#123; tmp += str.charAt(Math.floor(Math.random()*l)); &#125; return tmp; &#125; console.log(randomString(8)); 5.sort()方法：简单粗暴12345678var arr = [1, 9, 4, 50, 49, 6, 3, 2];function test()&#123; return arr.sort(sortNumber);&#125;function sortNumber(a, b)&#123; return a - b;&#125;test(); 6.笔者常用的数组去重方法：方法一123456789var arr = [1, 1, 4, 50, 50, 6, 2, 2];function test()&#123; return arr.filter(function(item,index,array)&#123; return array.indexOf(item) === index; //或者这样写return array.indexOf(item, index+1) === -1; 如果没有重复项，返回true //用filter方法，返回ietm对应的indexOf索引值与本身index索引值相等的值，也就是去掉重复的值，filter本身不修改数组，只是会自动遍历数组，去掉重复值后，那么arr就剩下不重复的了 &#125;);&#125;test();//输出Array [ 1, 4, 50, 6, 2 ] 方法二12345var arr = [1, 1, 4, 50, 50, 6, 2, 2];function unique(arr)&#123; return Array.from(new Set(arr));&#125;unique(arr); 7.AJAX都有哪些优点和缺点？1.页面无刷新，用户体验好。2.使用异步与服务器通信，响应更迅速。3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 ajax的缺点1、ajax不支持浏览器back按钮。2、安全问题 AJAX暴露了与服务器交互的细节。3、对搜索引擎的支持比较弱。4、破坏了程序的异常机制。5、不容易调试。 8.用js正则实现一个字符串里指定的小写字母变大写1234567function rePlaceReg(reg,str)&#123; return str.replace(reg, function(m)&#123; return m.toUpperCase(); &#125;)&#125;var result = replaceReg(/[x]&#123;3&#125;\\.[x]&#123;3&#125;[b]/g, 'xxx.xxxbggx'); console.log(result); //XXX.XXXBggx","categories":[],"tags":[],"keywords":[]},{"title":"wordpress_logo","slug":"wordpress-logo","date":"2016-08-12T13:13:48.000Z","updated":"2016-08-12T13:17:27.000Z","comments":true,"path":"2016/08/12/wordpress-logo/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/08/12/wordpress-logo/","excerpt":"","text":"123456789101112131415//添加logo function.php 设置add_theme_support( 'custom-header', array( 'default-image' =&gt; '', 'random-default' =&gt; false, 'width' =&gt; 133, 'height' =&gt; 33, 'flex-height' =&gt; true, 'flex-width' =&gt; true, 'default-text-color' =&gt; '', 'header-text' =&gt; true, 'uploads' =&gt; true, 'wp-head-callback' =&gt; '', 'admin-head-callback' =&gt; '', 'admin-preview-callback' =&gt; '',) ); logo调用1234567&lt;!-- logo --&gt; &lt;?php if (get_header_image()) : ?&gt; &lt;a href=\"&lt;?php echo get_option('home') ?&gt;\"&gt; &lt;img src=\"&lt;?php header_image(); ?&gt;\" height=\"&lt;?php echo get_custom_header()-&gt;height; ?&gt;\" width=\"&lt;?php echo get_custom_header()-&gt;width; ?&gt;\" alt=\"&lt;?php bloginfo('name');?&gt;\"&gt; &lt;/a&gt; &lt;?php endif; ?&gt;","categories":[],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"http://diyxiaoshitou.github.io/tags/wordpress/"}],"keywords":[]},{"title":"wordpress 缩略图功能函数 the_post_thumbnail","slug":"缩略图","date":"2016-08-09T06:33:34.000Z","updated":"2016-08-09T06:41:34.000Z","comments":true,"path":"2016/08/09/缩略图/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/08/09/缩略图/","excerpt":"","text":"很多 WordPress 主题，特别是那些杂志型的主题，会给每篇日志加上一张缩略图，这种展现方式一般用在首页，可能单独出现，或者和日志摘要一起。但是目前位置没有一个标准的方法去实现日志缩略图，很多主题是使用 WordPress 自定义字段来实现日志缩略图功能，这样的设置比较复杂，虽然我在制作的很多 WordPress 项目中都是用这个方法，并且设置了直接上传缩略图的方法，但是还是略显麻烦。 从 WordPress 2.9 开始，WordPress 开始内置了日志缩略图的功能，并且提供了详细的接口让主题的作者设置和调用日志的缩略图。 第一步：让主题支持缩略图功能首先确保你的wordpress版本在2.9之上，然后在你的当前主题文件夹中找到并编辑functions.php文件，加入下面这句代码1234&lt;?phpif ( function_exists( 'add_theme_support' ) ) add_theme_support( 'post-thumbnails' );?&gt; (注：主题文件夹都保存在wp-content/themes/目录下) 第二步：使用缩略图在需要显示缩略图的地方调用the_post_thumbnail函数，比如你想在首页为每篇文章显示缩略图，可以在index.php文件中加入下面这样的代码 1234&lt;? php if ( function_exists( &apos;the_post_thumbnail&apos; ) ) the_post_thumbnail( &apos;thumbnail&apos; );?&gt; 这样就能显示缩略图了，其中参数”thumbnail”表示缩略图显示的大小。wordpress预置了4种大小，你可以使用下面的4个参数来替换’thumbnail’，当然不同的台数显示的图片大小也不同 Ø Thumbnail (缩略图尺寸) Ø Medium （中等尺寸） Ø Large （大尺寸） Ø Full （原始尺寸） 具体尺寸大小可以在后台“设置”中的“媒体”选项中进行设置 你可以设置3种不同的大小，以方便在不同的情况下使用。 至此你的主题已经支持缩略图功能并可以灵活使用了。 下面我将介绍一下更高级的应用技巧。 自定义缩略图尺寸的三种方法方法一：后台设置就是上面提到的方法，不过这种方法只设置3种大小。 方法二：自定义在调用the_post_thumbnail函数的时候，可以直接指定缩略图的大小1the_post_thumbnail(array(200,200)); // 显示200X200尺寸的缩略图 这种方法的优点的灵活，可以随时通过代码的调用显示不同尺寸的图片，缺点是修改有点麻烦，如果你有多处这样的代码，修改起来就要把每一处代码都要修改掉。 方法三：增加预置尺寸通过前面的介绍我们已经知道，wordpress为我们预置了三种可以设置的尺寸。可不可以再增加一些预置的尺寸呢？当然可以，我们要用到的函数是add_image_size。比如我们想在首页和分类页面使用不同的缩略图大小，就可以先预置homepage-thumb和category-thumb这两大小。方法是在functions.php文件中加入以下代码 1234if ( function_exists( &apos;add_image_size&apos; ) )&#123; add_image_size( &apos;category-thumb&apos;, 200, 200 ); // 预置一个名为’category-thumb’,200*200的缩略图大小 add_image_size( &apos;homepage-thumb&apos;, 220, 180); //预置一个名为’homepage-thumb’,220*180的缩略图大小 &#125; 之后就可以在首页调用1the_post_thumbnail(‘homepage-thumb’); 显示220*180的缩略图 在分类页面调用1the_post_thumbnail(‘category-thumb’); 则显示200*200的缩略图。 定义缩略图的样式首先我们先来看一下the_post_thumbnail函数输出的html是什么样的 12&lt;img width=&quot;150&quot; height=&quot;150&quot; src=&quot;http://domety.com/wp-content/uploads/2010/10/screenshot-150x150.png&quot;class=&quot;attachment-thumbnail wp-post-image&quot; alt=&quot;&quot; title=&quot;screenshot&quot; /&gt; 由此可以看出，我们可以用css定义类attachment-thumbnail的样式就可以了。 但是如果我想分别为首页和分类页面定义不同的样式，该怎么做呢？ 方法一是增加一个div，针对不同的div定义不同的样式，在此不多做介绍。 我要介绍的是另一种方法：给缩略图添加属性 你可以测试一下，如果把the_post_thumbnail(“thumbnail”)修改为下面这样的代码，看看输出的html结果是什么？ 1the_post_thumbnail(‘thumbnail’,array(‘class’ =&gt; ‘homepage-thumb’)); 我这边输出的html为12&lt;img width=&quot;150&quot; height=&quot;150&quot; src=&quot;http://domety.com/wp-content/uploads/2010/10/screenshot-150x150.png&quot;class=&quot;homepage-thumb wp-post-image&quot; alt=&quot;&quot; title=&quot;screenshot&quot; /&gt; 可以和之前的html对比一下，不难发现class属性变成了我们设置的’homepage-thumb’。可以通过这种方法，把首页缩略图和分类页面的缩略图设置为不同的class属性。 改变THE_POST_THUMBNAIL的HTML输出我们可以使用filter来改变缩略图的html输出结果，下面的这段代码为缩略图加了一个文章链接 12345add_filter( &apos;post_thumbnail_html&apos;, &apos;my_post_image_html&apos;, 10, 3 ); function my_post_image_html( $html, $post_id, $post_image_id ) &#123; $html = &apos;&lt;a href=&quot;&apos; . get_permalink( $post_id ) . &apos;&quot; title=&quot;&apos; . esc_attr( get_post_field( &apos;post_title&apos;, $post_id ) ) . &apos;&quot;&gt;&apos; . $html . &apos;&lt;/a&gt;&apos;; return $html; &#125; 当你点击缩略图的时候就会跳转到相应的文章内页。 检测文章是否有缩略图一个良好的习惯就是在调用the_post_thumbnail函数之前，先检测一下该文章有没有设置缩略图，检测的方法是调用has_post_thumbnail函数，代码如下12&lt;?php if ( has_post_thumbnail() ) the_post_thumbnail( &apos;thumbnail&apos; );?&gt; 结合本站之前的提取文章内图片做为缩略图的方法，现在可以合二为一：首先判断文章有没有设置缩略图，如果有就直接显示，如果没有再提取文章内的图片为缩略图。 1234567891011121314151617181920212223242526272829303132333435363738394041/* * 缩略图*/function dm_the_thumbnail() &#123; global $post; // 判断该文章是否设置的缩略图，如果有则直接显示 if ( has_post_thumbnail() ) &#123; echo &apos;&lt;a href=&quot;&apos;.get_permalink().&apos;&quot; title=&quot;阅读全文&quot;&gt;&apos;; the_post_thumbnail(&apos;thumbnail&apos;); echo &apos;&lt;/a&gt;&apos;; &#125; else &#123; //如果文章没有设置缩略图，则查找文章内是否包含图片 $content = $post-&gt;post_content; preg_match_all(&apos;/&lt;img.*?(?: |\\\\t|\\\\r|\\\\n)?src=[\\&apos;&quot;]?(.+?)[\\&apos;&quot;]?(?:(?: |\\\\t|\\\\r|\\\\n)+.*?)?&gt;/sim&apos;, $content, $strResult, PREG_PATTERN_ORDER); $n = count($strResult[1]); if($n &gt; 0)&#123; // 如果文章内包含有图片，就用第一张图片做为缩略图 echo &apos;&lt;a href=&quot;&apos;.get_permalink().&apos;&quot; title=&quot;阅读全文&quot;&gt;&lt;img src=&quot;&apos;.$strResult[1][0].&apos;&quot; alt=&quot;缩略图&quot; /&gt;&lt;/a&gt;&apos;; &#125;else &#123; // 如果文章内没有图片，则用默认的图片。 echo &apos;&lt;a href=&quot;&apos;.get_permalink().&apos;&quot; title=&quot;阅读全文&quot;&gt;&lt;img src=&quot;&apos;.get_bloginfo(&apos;template_url&apos;).&apos;/imgs/default_thumbnail.jpg&quot; alt=&quot;缩略图&quot; /&gt;&lt;/a&gt;&apos;; &#125; &#125; &#125; 有兴趣的朋友可以把以上代码复制到functions.php文件中，然后调用dm_the_thumbnail()即可。","categories":[],"tags":[],"keywords":[]},{"title":"获取wordpress内容","slug":"获取wordpress内容","date":"2016-08-08T08:09:43.000Z","updated":"2016-08-08T08:10:51.000Z","comments":true,"path":"2016/08/08/获取wordpress内容/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/08/08/获取wordpress内容/","excerpt":"","text":"1apply_filters(&apos;the_content&apos;, $post-&gt;post_content)","categories":[],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"http://diyxiaoshitou.github.io/tags/wordpress/"}],"keywords":[]},{"title":"mac sublime3快捷键","slug":"sublime快捷键","date":"2016-08-04T07:40:28.000Z","updated":"2016-11-23T02:43:01.000Z","comments":true,"path":"2016/08/04/sublime快捷键/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/08/04/sublime快捷键/","excerpt":"","text":"123456⌘ + shift + k //编辑成对的元素标签control + shift + k //删除行⌘ + shift + d //复制行shift + alt //选择单词⌘+k ⌘+l //转换成小写⌘+k ⌘+u //转换成大写 打开/前往12345678⌘T 前往文件⌘⌃P 前往项目⌘R 前往 method⌘⇧P 命令提示⌃G 前往行⌘KB 开关侧栏 ⌃ ` python 控制台⌘⇧N 新建窗口 编辑123456789101112131415161718192021222324⌘L 选择行 (重复按下将下一行加入选择)⌘D 选择词 (重复按下时多重选择相同的词进行多重编辑)⌃⇧M 选择括号内的内容⌘⇧↩ 在当前行前插入新行⌘↩ 在当前行后插入新行⌃⇧K 删除行⌘KK 从光标处删除至行尾⌘K⌫ 从光标处删除至行首⌘⇧D 复制(多)行⌘J 合并(多)行⌘KU 改为大写⌘KL 改为小写⌘ / 注释⌘⌥ / 块注释⌘Y 恢复或重复⌘⇧V 粘贴并自动缩进⌃ space 自动完成(重复按下选择下一个提示)⌃M 跳转至对应的括号⌘U 软撤销（可撤销光标移动）⌘⇧U 软重做（可重做光标移动）XML /HTML⌘⇧A 选择标签内的内容⌘⌥ . 闭合当前标签 查找/替换1234567891011121314⌘F 查找⌘⌥F 替换⌘⌥G 查找下一个符合当前所选的内容⌘⌃G 查找所有符合当前所选的内容进行多重编辑⌘⇧F 在所有打开的文件中进行查找拆分窗口/标签页⌘⌥1 单列⌘⌥2 双列⌘⌥5 网格 (4组)⌃[1,2,3,4] 焦点移动至相应组⌃⇧[1,2,3,4] 将当前文件移动至相应组⌘[1,2,3…] 选择相应标签页 书签12345⌘F2 添加/去除书签F2 下一个书签⇧F2 前一个书签⌘⇧F2 清除书签 标记12345⌘K space 设置标记⌘KW 从光标位置删除至标记⌘KA 从光标位置选择至标记⌘KG 清除标记","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://diyxiaoshitou.github.io/tags/Mac/"}],"keywords":[]},{"title":"wordpress菜单","slug":"wordpress菜单","date":"2016-07-27T03:14:36.000Z","updated":"2016-07-27T05:43:34.000Z","comments":true,"path":"2016/07/27/wordpress菜单/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/07/27/wordpress菜单/","excerpt":"","text":"1.添加菜单 function.php 123456789101112//添加菜单if (function_exists('register_nav_menus')) &#123; register_nav_menus( array( 'header-menu'=&gt;__('主菜单'), // 设置菜单的位置,设置后会在后台显示出来,后台可以设置主题对应的位置 'sub-menu'=&gt;__('副菜单'), 'sider-menu'=&gt;__('侧边菜单'), 'footer-menu'=&gt;__('底部的菜单'), ) );&#125; 2.页面调用 菜单下面的代码不用都写后台可以设置菜单对应的位置12345678910111213141516171819202122232425&lt;?php//wp_nav_menu( array( 'theme_location' =&gt;'sub-menu', //菜单的位置 'menu'=&gt;'sub-menu', //菜单的名称 'container' =&gt; 'nav', //最外层容器标签名 'container_class' =&gt; 'primary', //最外层容器class名 'container_id' =&gt; 'feng',//最外层容器id值 'menu_class' =&gt; 'sf-menu', //ul标签class 'menu_id' =&gt; 'topnav',//ul标签id 'echo' =&gt; true,//是否打印，默认是true，如果想将导航的代码作为赋值使用，可设置为false 'fallback_cb' =&gt; 'wp_page_menu',//备用的导航菜单函数，用于没有在后台设置导航时调用 'before' =&gt; '&lt;p&gt;',//显示在导航a标签之前 'after' =&gt; '&lt;/p&gt;',//显示在导航a标签之后 'link_before' =&gt; '?',//显示在导航链接名之后 'link_after' =&gt; '??',//显示在导航链接名之前// 'items_wrap' =&gt; '&lt;ul id=\"%1$s\"&gt;%3$s&lt;/ul&gt;', //输出ul的格式,如果打开ul的class将去掉 'depth' =&gt; 0,////显示的菜单层数，默认0，0是显示所有层 'walker' =&gt; ''// //调用一个对象定义显示导航菜单 ));例如菜单的描述 ))?&gt;","categories":[],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"http://diyxiaoshitou.github.io/tags/wordpress/"}],"keywords":[]},{"title":"wordpress体验","slug":"wordpress体验","date":"2016-07-26T12:09:59.000Z","updated":"2016-08-09T17:39:49.000Z","comments":true,"path":"2016/07/26/wordpress体验/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/07/26/wordpress体验/","excerpt":"","text":"阅读设置首页显示您的最新文章（index.php）相当于文章列表页一个静态页面（在下方选择） (如果选择这个)主页： page.php(默认) 如果有front-page.php会优先调用显示文章页： 相当于文章列表页 front-page 首页 index.php //（默认首页）新闻列表 page //单页面 single.php // 文章页 sidebar.php //侧边栏 页面规划所有的标题的导航|子导航，应该用 分类，和单页面里边的内容，应该用 新闻列表，帖子列表 12345678910111213bloginfo('template_url') //模板根目录home_url() //获取根路径 需要输出get_option('home') //获取根路径 需要输出get_post_meta(get_the_ID(), 'jianjie', true) //获取自定义字段为“jianjie”的内容 需要输出the_permalink() //获取连接the_title() //获取标题the_post_thumbnail('full') //获取缩略图the_time('l, F jS, Y') //获取时间the_content() //获取内容wp_list_pages('title_li=&lt;h4&gt;'.__('关于我们').'&lt;/h4&gt;&amp;child_of=149&amp;sort_column=post_date') //获取页面的列表wp_nav_menu('theme_location=footer-menu-support') //获取菜单 查询 12345678910query_posts(\"showposts=5&amp;cat=13\"); //查询$query_scroll = new WP_Query(\"showposts=5&amp;cat=13\"); //查询建议用这个&lt;?php if ($query_scroll-&gt;have_posts()): while ($query_scroll-&gt;have_posts()): $query_scroll-&gt;the_post(); ?&gt; &lt;?php the_post_thumbnail('full') ?&gt;&lt;?php endwhile; endif; ?&gt;wp_reset_query();// 重置查询apply_filters('the_content',$post-&gt;post_content) //单独获取内容 调用样式1&lt;link rel=\"stylesheet\" href=\"&lt;?php bloginfo('stylesheet_url')?&gt;\"&gt; //调用样式 默认添加123wp_enqueue_script(\"jquery\") //必须在下面的前面wp_head()wp_footer() 调用模板123get_template_part(&apos;single-product&apos;) //调用模板comments_template() //调用默认的评论模板get_sidebar() //引用侧栏 判断1in_category(array(18,20,21)) //在分类里","categories":[],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"http://diyxiaoshitou.github.io/tags/wordpress/"}],"keywords":[]},{"title":"单行向上滚动","slug":"单行向上滚动","date":"2016-07-26T10:14:02.000Z","updated":"2016-07-26T10:17:56.000Z","comments":true,"path":"2016/07/26/单行向上滚动/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/07/26/单行向上滚动/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"http://www.lanrenzhijia.com/ajaxjs/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;style type=\"text/css\"&gt; p&#123; height: 80px; overflow: hidden; width: 200px;&#125; p a&#123; display: block; height: 80px; &#125; &lt;/style&gt;&lt;p id=\"ty-text-slide\" style=\"position:relative;\"&gt; &lt;a style=\"position: relative; margin-top: 0px;\" href=\"#\"&gt;中央部门晒决算 国税系统津贴福利开支占近6成_新闻中心_中国网 &lt;/a&gt; &lt;a style=\"position: relative; margin-top: 0px;\" href=\"#\"&gt;房地产税法最快2017年通过 百万房产或每年缴5千 &lt;/a&gt; &lt;a style=\"position: relative; margin-top: 0px;\" href=\"#\"&gt;美媒:中国援助阿富汗打击恐怖组织 首批军事装备抵阿 &lt;/a&gt;&lt;/p&gt;&lt;script type=\"text/javascript\"&gt; // 显示滚动文字 var scroll_event; var $scroll_parent = $(\"#ty-text-slide\"); var scroll_height = $scroll_parent.find('a:first').height(); $scroll_parent.hover(function () &#123; clearInterval(scroll_event); &#125;, function () &#123; scroll_event = setInterval(function () &#123; var _this = $scroll_parent; _this.find('a:first').animate(&#123;\"marginTop\": -scroll_height + 'px'&#125;, 500, function () &#123; _this.find(\"a:first\").css(&#123;marginTop: \"0px\"&#125;).appendTo(_this); &#125;) &#125;, 2000); &#125;).trigger(\"mouseout\"); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://diyxiaoshitou.github.io/tags/js/"}],"keywords":[]},{"title":"使用 Travis CI 自动更新 GitHub Pages","slug":"markdown","date":"2016-07-14T02:03:24.000Z","updated":"2016-07-27T17:51:34.000Z","comments":true,"path":"2016/07/14/markdown/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/07/14/markdown/","excerpt":"","text":"每次更改完 NexT 文档 都要手动部署到 GitHub Pages，重复的次数多了就显得很麻烦，出错的几率也会变大。文档源码放置在 master 分支，最终部署文件在 gh-pages 分支。当在 master 分支更改某些内容之后，通过运行 gulp dist 来生成最终部署的 HTML 文件到 dist 目录，随后再进入 dist 目录初始化 git 仓库、添加文件、提交文件，最后将提交强制推送到远程 gh-pages 分支（因当心我会误将最终部署的 HTML 文件提交到 master 分支导致源码丢失，我在 GitHub 上把 master 分支给锁定了）。除此之外还有另外一个问题：如果 master 分支有 Pull Requests，我需要先将更新取回本地，然后编译更新再提交回远程 gh-pages 分支。 年轻的想法 于是，我就想这说将这个过程自动化。首先考虑了使用 GitHub Webhooks，这是 Github 提供的一种机制，使应用能与 Github 通讯。这种机制实际上就是 Pub/Sub，当 Github 监测到资源（如仓库）有变化就往预先设定的 URL 发送一个 POST 请求（Pub），告知变化情况，而后接收变化的服务器（Sub）即可做一些额外的事情。 这个思路需要有一个服务器并启动一个服务来接收 Github 的请求。这里又有种不同的策略，这两种策略都是基于源码放置在 Github 的前提。第一个是源码将最终文档直接部署在这台服务器上（如使用 Nginx），当接收到 Github 通知直接编译更新到服务器指定的文件夹下即可。另一种策略是当服务器接收到通知后编译更新，而后将编译后的版本提交到 Github 仓库的 gh-pages 分支，让 Github 做 Host。","categories":[],"tags":[],"keywords":[]},{"title":"nginx.conf","slug":"nginx-conf","date":"2016-07-13T17:38:06.000Z","updated":"2016-07-27T16:11:04.000Z","comments":true,"path":"2016/07/14/nginx-conf/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/07/14/nginx-conf/","excerpt":"","text":"这个是nginx的主配置文件，其中 include servers/*.conf; 里包含了servers配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"';#access_log logs/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; client_body_timeout 10; client_header_timeout 10;#keepalive_timeout 0; keepalive_timeout 65; send_timeout 10; server_tokens off; client_max_body_size 300m; client_body_buffer_size 8K; client_header_buffer_size 1k; large_client_header_buffers 4 4k; server_names_hash_bucket_size 128;## gzip gzip on; gzip_disable \"MSIE [1-6]\\.\"; gzip_vary on; gzip_min_length 1000; gzip_proxied expired no-cache no-store private auth; gzip_comp_level 6; gzip_buffers 16 8k; gzip_http_version 1.1; gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; include servers/*.conf;#add_header Access-Control-Allow-Origin *;#add_header Access-Control-Allow-Headers X-Requested-With;#add_header Access-Control-Allow-Methods GET,POST,OPTIONS;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://diyxiaoshitou.github.io/tags/nginx/"}],"keywords":[]},{"title":"phone.conf","slug":"phone-conf","date":"2016-07-13T17:27:18.000Z","updated":"2016-07-13T17:36:57.000Z","comments":true,"path":"2016/07/14/phone-conf/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/07/14/phone-conf/","excerpt":"","text":"nginx反向代理当访问接口 http://phone.app/v1 时，会自动代理到 http://10.2.10.92:8080/v1 123456789101112131415161718192021222324252627282930313233#-------------------------------------------#java 站点 负载模板配置文件，将_DOMAIN_替换成相应的域名,_PORT_ 替换成对应的端口#-------------------------------------------#upstream mysvr &#123;##weigth参数表示权值，权值越高被分配到的几率越大##本机上的Squid开启3128端口# server 10.2.10.92:8080 weight=6;#&#125;server&#123; listen 80; server_name phone.app; root /Users/diyxiaoshitou/WebstormProjects/phone; index index.html index.htm; location /v1 &#123; proxy_pass http://10.2.10.92:8080; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-for $proxy_add_x_forwarded_for; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; proxy_max_temp_file_size 0; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; &#125;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://diyxiaoshitou.github.io/tags/nginx/"}],"keywords":[]},{"title":"wordpress_conf","slug":"wordpress-conf","date":"2016-07-13T17:15:37.000Z","updated":"2016-07-13T17:36:27.000Z","comments":true,"path":"2016/07/14/wordpress-conf/","link":"","permalink":"http://diyxiaoshitou.github.io/2016/07/14/wordpress-conf/","excerpt":"","text":"这个配置文件主要配置server_name和root 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263server &#123; listen 80; server_name wordpress.app; root /Users/diyxiaoshitou/wordpress; index index.html index.htm index.php; #charset koi8-r;# access_log logs/access.log; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; location ~ /\\. &#123; deny all; access_log off; log_not_found off; &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ &#123; fastcgi_buffers 2 256k; fastcgi_buffer_size 128K; fastcgi_busy_buffers_size 256K; fastcgi_temp_file_write_size 256k; fastcgi_connect_timeout 3000; fastcgi_send_timeout 3000; fastcgi_read_timeout 3000; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; #fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # location ~ /\\.ht &#123; deny all; &#125; location ~ /\\.git &#123; deny all; &#125;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://diyxiaoshitou.github.io/tags/nginx/"}],"keywords":[]}]}